# A helper script to populate vtable in BiosParserServices
# @author Nyan Cat
# @category A_Red
# @keybinding
# @menupath
# @toolbar

# pyright: reportMissingImports=false
# pyright: reportUndefinedVariable=false

from java.util import ArrayList

from ghidra.program.model.data import CategoryPath, FunctionDefinitionDataType, PointerDataType
from ghidra.program.model.data import DataTypeConflictHandler


def getDataType(typeName, typeManager):
    matches = ArrayList()
    typeManager.findDataTypes(typeName, matches)

    if len(matches) > 1:
        print("Warning: Using the first " + typeName)
    elif len(matches) == 0:
        return None

    return matches[0]


funcManager = currentProgram.getFunctionManager()
typeManager = currentProgram.getDataTypeManager()

funcNames = ["allocateMemory", "deallocateMemory", "readReg32", "writeReg32", "readPll32",
             "writePll32", "readMc32", "writeMc32", "readPci8", "writePci8",
             "readPci16", "writePci16", "readPci32", "writePci32", "delayMicro",
             "delayMilli", "printOut"]
funcNames = ["AtomBiosProxy::" + x for x in funcNames]
done = [False] * len(funcNames)
ptrs = [None] * len(funcNames)

for func in funcManager.getFunctions(True):
    funcName = str(func)
    if funcName not in funcNames:
        continue

    funcIndex = funcNames.index(funcName)
    funcSign = func.getSignature(False)

    funcType = FunctionDefinitionDataType(CategoryPath("/AMDGen/FuncSigns"), funcName + "_sign", funcSign)
    funcType = typeManager.addDataType(funcType, DataTypeConflictHandler.REPLACE_HANDLER)
    ptrType = PointerDataType(funcType, typeManager)
    ptrType = typeManager.addDataType(ptrType, DataTypeConflictHandler.REPLACE_HANDLER)
    done[funcIndex] = True
    ptrs[funcIndex] = ptrType

    print(funcName + "_sign *")

assert all(done)

biosParser = getDataType("BiosParserServices", typeManager)
for i in range(len(funcNames)):
    biosParser.replaceAtOffset(32 + 8 * i, ptrs[i], 8, funcNames[i], "Generated by Z_createBiosParserServicesVtable.py")
